# üì¶ GerLang Modulsystem: Import & Export

> Das **GerLang Modulsystem** erm√∂glicht die Strukturierung gro√üer Programme in wiederverwendbare Module mit klarer Import/Export-Syntax.

---

## ‚ú® √úberblick

### üéØ Warum Module?
- **Wiederverwertbarkeit:** Code einmal schreiben, √ºberall nutzen
- **Organisation:** Gro√üe Projekte in √ºberschaubare Teile aufteilen
- **Namensr√§ume:** Konflikte bei Funktions-/Variablennamen vermeiden
- **Teamarbeit:** Verschiedene Entwickler arbeiten an verschiedenen Modulen

### üîß Grundprinzipien
- **Explizit:** Nur explizit exportierte Namen sind verf√ºgbar
- **Sicher:** Keine versehentlichen Exporten
- **Flexibel:** Verschiedene Export-Methoden
- **√úbersichtlich:** Klare Import/Export-Syntax

---

## üì§ Export von Funktionen und Variablen

### 1. Direkt-Export (bei Definition)
Exportiere Funktionen und Variablen direkt bei ihrer Definition:

```gerlang
// math_utils.gerl - Mathematik-Hilfsfunktionen

// Direkt-Export einer Funktion
GIBFREI GANZ addiere(a: GANZ, b: GANZ) {
    ZUR√úCK a + b;
}

GIBFREI GANZ multipliziere(a: GANZ, b: GANZ) {
    ZUR√úCK a * b;
}

// Direkt-Export einer Konstante
GIBFREI KOMMA PI = 3.14159265359;
GIBFREI GANZ MAX_WERT = 999999;

// Private Hilfsfunktion (nicht exportiert)
GANZ interne_berechnung(x: GANZ) {
    ZUR√úCK x * x + 1;
}
```

### 2. Export-Liste (nachtr√§gliche Freigabe)
Definiere Funktionen normal und exportiere sie sp√§ter:

```gerlang
// string_utils.gerl - String-Hilfsfunktionen

// Normale Definitionen
GANZ z√§hle_w√∂rter(text: WORT) {
    // Vereinfachte Implementierung
    GANZ anzahl = 1;
    F√úR (GANZ i = 0; i < text.L√ÑNGE; i = i + 1) {
        WENN (text[i] == " ") {
            anzahl = anzahl + 1;
        }
    }
    ZUR√úCK anzahl;
}

WORT grossbuchstaben(text: WORT) {
    // Vereinfachte Implementierung
    ZUR√úCK text;  // TODO: Implementierung
}

JAIN ist_leer(text: WORT) {
    ZUR√úCK text.L√ÑNGE == 0;
}

// Private Hilfsfunktion
GANZ interne_string_verarbeitung(text: WORT) {
    ZUR√úCK text.L√ÑNGE * 2;
}

// Export-Liste am Ende
GIBFREI z√§hle_w√∂rter, grossbuchstaben, ist_leer;
```

### 3. Gemischter Export
Kombiniere beide Methoden nach Bedarf:

```gerlang
// game_engine.gerl - Spiel-Engine

// Direkt-Export wichtiger Konstanten
GIBFREI GANZ BILDSCHIRM_BREITE = 800;
GIBFREI GANZ BILDSCHIRM_H√ñHE = 600;
GIBFREI WORT VERSION = "1.0.0";

// Normale Definitionen
JAIN spiel_l√§uft = JA;

NIX initialisiere_spiel() {
    DRUCKE("Spiel wird initialisiert...");
    spiel_l√§uft = JA;
}

NIX beende_spiel() {
    DRUCKE("Spiel wird beendet...");
    spiel_l√§uft = NEIN;
}

// Nachtr√§glicher Export
GIBFREI initialisiere_spiel, beende_spiel, spiel_l√§uft;
```

---

## üì• Import von Funktionen und Variablen

### Grundsyntax
```gerlang
HOLE name1, name2, name3 VON "modulname.gerl";
```

### Einfacher Import
```gerlang
// main.gerl - Hauptprogramm
HOLE addiere, PI VON "math_utils.gerl";

GANZ haupt() {
    GANZ summe = addiere(5, 3);          // 8
    DRUCKE("Summe: " + summe);
    DRUCKE("PI: " + PI);                 // 3.14159265359
    ZUR√úCK 0;
}
```

### Multiple Imports
```gerlang
// calculator.gerl - Taschenrechner
HOLE addiere, multipliziere, PI VON "math_utils.gerl";
HOLE z√§hle_w√∂rter, ist_leer VON "string_utils.gerl";
HOLE BILDSCHIRM_BREITE, initialisiere_spiel VON "game_engine.gerl";

GANZ haupt() {
    // Mathematik verwenden
    GANZ result = multipliziere(addiere(2, 3), 4);  // (2+3)*4 = 20
    
    // String-Verarbeitung
    WORT text = "Hallo Welt Programmierung";
    GANZ w√∂rter = z√§hle_w√∂rter(text);               // 3
    
    // Spiel-Engine
    DRUCKE("Bildschirmbreite: " + BILDSCHIRM_BREITE);
    initialisiere_spiel();
    
    DRUCKE("Rechnung: " + result);
    DRUCKE("W√∂rter: " + w√∂rter);
    ZUR√úCK 0;
}
```

---

## üèóÔ∏è Praktische Module-Beispiele

### Beispiel 1: Mathe-Bibliothek
```gerlang
// math_lib.gerl - Erweiterte Mathematik-Bibliothek

// Konstanten
GIBFREI KOMMA PI = 3.14159265359;
GIBFREI KOMMA E = 2.71828182846;

// Grundrechenarten
GIBFREI GANZ addiere(a: GANZ, b: GANZ) {
    ZUR√úCK a + b;
}

GIBFREI GANZ subtrahiere(a: GANZ, b: GANZ) {
    ZUR√úCK a - b;
}

// Erweiterte Funktionen
GANZ potenz(basis: GANZ, exponent: GANZ) {
    GANZ result = 1;
    F√úR (GANZ i = 0; i < exponent; i = i + 1) {
        result = result * basis;
    }
    ZUR√úCK result;
}

GANZ fakult√§t(n: GANZ) {
    WENN (n <= 1) {
        ZUR√úCK 1;
    }
    ZUR√úCK n * fakult√§t(n - 1);
}

GANZ gcd(a: GANZ, b: GANZ) {
    SOLANGE (b != 0) {
        GANZ temp = b;
        b = a % b;
        a = temp;
    }
    ZUR√úCK a;
}

// Export der erweiterten Funktionen
GIBFREI potenz, fakult√§t, gcd;
```

### Beispiel 2: Datenstrukturen-Modul
```gerlang
// data_structures.gerl - Datenstrukturen und Algorithmen

// Stack-Implementation mit Array
KISTE stack = [];

NIX stack_push(wert: GANZ) {
    stack.ERWEITERN(wert);
}

GANZ stack_pop() {
    WENN (stack.L√ÑNGE == 0) {
        MECKER("Stack ist leer!");
    }
    GANZ wert = stack[stack.L√ÑNGE - 1];
    // TODO: Element entfernen (simplified)
    ZUR√úCK wert;
}

JAIN stack_ist_leer() {
    ZUR√úCK stack.L√ÑNGE == 0;
}

// Sortieralgorithmen
NIX bubble_sort(arr: KISTE) {
    GANZ n = arr.L√ÑNGE;
    F√úR (GANZ i = 0; i < n - 1; i = i + 1) {
        F√úR (GANZ j = 0; j < n - i - 1; j = j + 1) {
            WENN (arr[j] > arr[j + 1]) {
                GANZ temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// Suchfunktionen
GANZ linear_search(arr: KISTE, ziel: GANZ) {
    F√úR (GANZ i = 0; i < arr.L√ÑNGE; i = i + 1) {
        WENN (arr[i] == ziel) {
            ZUR√úCK i;
        }
    }
    ZUR√úCK -1;  // Nicht gefunden
}

GIBFREI stack_push, stack_pop, stack_ist_leer;
GIBFREI bubble_sort, linear_search;
```

### Beispiel 3: Spiel-Utilities
```gerlang
// game_utils.gerl - Spiel-Hilfsfunktionen

// Spiel-Konstanten
GIBFREI GANZ MAX_LEBEN = 100;
GIBFREI GANZ MAX_PUNKTE = 999999;

// Spieler-Status
GANZ spieler_leben = MAX_LEBEN;
GANZ spieler_punkte = 0;

// Spieler-Funktionen
NIX schaden_nehmen(schaden: GANZ) {
    spieler_leben = spieler_leben - schaden;
    WENN (spieler_leben < 0) {
        spieler_leben = 0;
    }
    DRUCKE("üíî Schaden: " + schaden + " (Leben: " + spieler_leben + ")");
}

NIX leben_heilen(heilung: GANZ) {
    spieler_leben = spieler_leben + heilung;
    WENN (spieler_leben > MAX_LEBEN) {
        spieler_leben = MAX_LEBEN;
    }
    DRUCKE("üíö Heilung: " + heilung + " (Leben: " + spieler_leben + ")");
}

NIX punkte_hinzuf√ºgen(punkte: GANZ) {
    spieler_punkte = spieler_punkte + punkte;
    WENN (spieler_punkte > MAX_PUNKTE) {
        spieler_punkte = MAX_PUNKTE;
    }
    DRUCKE("‚≠ê Punkte: +" + punkte + " (Total: " + spieler_punkte + ")");
}

JAIN ist_spieler_am_leben() {
    ZUR√úCK spieler_leben > 0;
}

NIX zeige_status() {
    DRUCKE("=== Spieler-Status ===");
    DRUCKE("Leben: " + spieler_leben + "/" + MAX_LEBEN);
    DRUCKE("Punkte: " + spieler_punkte);
    DRUCKE("Status: " + (ist_spieler_am_leben() ? "Lebendig" : "Tot"));
}

GIBFREI schaden_nehmen, leben_heilen, punkte_hinzuf√ºgen;
GIBFREI ist_spieler_am_leben, zeige_status;
```

---

## üéÆ Komplettes Projekt-Beispiel

### main.gerl - Hauptprogramm
```gerlang
// Imports aus verschiedenen Modulen
HOLE addiere, potenz, PI VON "math_lib.gerl";
HOLE bubble_sort, linear_search VON "data_structures.gerl";
HOLE schaden_nehmen, leben_heilen, zeige_status VON "game_utils.gerl";

GANZ haupt() {
    DRUCKE("üöÄ === Multi-Modul Demo ===\n");
    
    // Mathe-Bibliothek testen
    DRUCKE("üìä Mathematik:");
    GANZ summe = addiere(5, 3);
    GANZ quadrat = potenz(4, 2);
    DRUCKE("  5 + 3 = " + summe);
    DRUCKE("  4¬≤ = " + quadrat);
    DRUCKE("  œÄ = " + PI);
    DRUCKE("");
    
    // Datenstrukturen testen
    DRUCKE("üîç Datenstrukturen:");
    KISTE zahlen = [64, 34, 25, 12, 22, 11, 90];
    DRUCKE("  Original: " + zahlen);
    
    bubble_sort(zahlen);
    DRUCKE("  Sortiert: " + zahlen);
    
    GANZ index = linear_search(zahlen, 25);
    DRUCKE("  Index von 25: " + index);
    DRUCKE("");
    
    // Spiel-Utilities testen
    DRUCKE("üéÆ Spiel-Simulation:");
    zeige_status();
    
    schaden_nehmen(30);
    leben_heilen(15);
    zeige_status();
    
    DRUCKE("\n‚úÖ Alle Module erfolgreich getestet!");
    ZUR√úCK 0;
}
```

**Ausgabe:**
```
üöÄ === Multi-Modul Demo ===

üìä Mathematik:
  5 + 3 = 8
  4¬≤ = 16
  œÄ = 3.14159265359

üîç Datenstrukturen:
  Original: [64, 34, 25, 12, 22, 11, 90]
  Sortiert: [11, 12, 22, 25, 34, 64, 90]
  Index von 25: 3

üéÆ Spiel-Simulation:
=== Spieler-Status ===
Leben: 100/100
Punkte: 0
Status: Lebendig
üíî Schaden: 30 (Leben: 70)
üíö Heilung: 15 (Leben: 85)
=== Spieler-Status ===
Leben: 85/100
Punkte: 0
Status: Lebendig

‚úÖ Alle Module erfolgreich getestet!
```

---

## ‚ö†Ô∏è Wichtige Hinweise & Best Practices

### ‚úÖ Do's
```gerlang
// ‚úÖ Klare Modulnamen
// math_utils.gerl, string_helpers.gerl, game_engine.gerl

// ‚úÖ Zusammengeh√∂rige Funktionen gruppieren
GIBFREI addiere, subtrahiere, multipliziere, dividiere;

// ‚úÖ Konstanten exportieren
GIBFREI GANZ MAX_WERT = 999;
GIBFREI WORT VERSION = "1.0.0";

// ‚úÖ Private Hilfsfunktionen nicht exportieren
GANZ interne_berechnung(x: GANZ) { ... }  // Nicht exportiert

// ‚úÖ Dokumentation in Modulen
// math_utils.gerl - Grundlegende mathematische Operationen
// Autor: Max Mustermann
// Version: 1.2.0
```

### ‚ùå Don'ts
```gerlang
// ‚ùå Alles exportieren
GIBFREI interne_temp_variable, debug_helper, temp_func;

// ‚ùå Unklare Namen
HOLE f, g, h VON "utils.gerl";

// ‚ùå Zu gro√üe Module (> 200 Zeilen)
// Teile gro√üe Module in kleinere auf

// ‚ùå Zirkul√§re Abh√§ngigkeiten
// modul_a.gerl importiert von modul_b.gerl
// modul_b.gerl importiert von modul_a.gerl  // Problematisch!
```

### üîß Fehlerbehandlung
```gerlang
// Modul nicht gefunden
HOLE unbekannte_funktion VON "nicht_existiert.gerl";
// Fehler: Modul 'nicht_existiert.gerl' nicht gefunden

// Name nicht exportiert
HOLE private_funktion VON "math_utils.gerl";
// Fehler: 'private_funktion' ist nicht in 'math_utils.gerl' exportiert

// Typfehler beim Import
HOLE addiere VON "math_utils.gerl";
WORT result = addiere(1, 2);  // Fehler: addiere() gibt GANZ zur√ºck
```

---

## üìÅ Projektstruktur-Empfehlungen

```
mein_projekt/
‚îú‚îÄ‚îÄ main.gerl              // Hauptprogramm
‚îú‚îÄ‚îÄ lib/                   // Bibliotheken
‚îÇ   ‚îú‚îÄ‚îÄ math_utils.gerl
‚îÇ   ‚îú‚îÄ‚îÄ string_helpers.gerl
‚îÇ   ‚îî‚îÄ‚îÄ data_structures.gerl
‚îú‚îÄ‚îÄ game/                  // Spiel-spezifische Module
‚îÇ   ‚îú‚îÄ‚îÄ player.gerl
‚îÇ   ‚îú‚îÄ‚îÄ enemies.gerl
‚îÇ   ‚îî‚îÄ‚îÄ levels.gerl
‚îî‚îÄ‚îÄ tests/                 // Test-Dateien
    ‚îú‚îÄ‚îÄ test_math.gerl
    ‚îî‚îÄ‚îÄ test_game.gerl
```

---

## üöÄ Weiterf√ºhrende Themen

- üîß [Funktionen & Parameter](funktionen.md)
- üìä [Arrays & Datenstrukturen](arrays.md)
- üõ°Ô∏è [Fehlerbehandlung](fehlerbehandlung.md)
- üí° [Praktische Beispiele](BEISPIELE.md)
- ‚ùì [FAQ & Troubleshooting](faq.md)

---

**Mit dem GerLang Modulsystem baust du saubere, wartbare und wiederverwendbare Programme! üì¶**
